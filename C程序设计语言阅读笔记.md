# 类型运算符和表达式

- 变量和常量
- 声明变量
- 运算符
- 表达式
- 对象的类型

## 变量名

- 字母开头，_视为字母，大小写敏感
- 内部名，至少前31个字符有效，函数名和外部变量名包含的字符数可能小于31，因为汇编程序和加载程序可能会使用这些外部名。
- 不能用保留字
- 局部变量一般使用较短的，外部变量使用较长的。

## 数据类型及长度

- char，字符型，一个字节
- int 整型，机器中最自然长度（x64，4字节）
- float 单精度浮点数，（x64，4字节）
- double 双精度浮点数（x64，8字节）

限定符

- short int（通常为16位)
- long int
- short和int至少16位，long至少32位，short类型不长于int类型，int类型不长于long类型
- signed char，int，float，double
- unsigned char，int，float，double

## 常量

- long类型的常量以l或者L结尾
- 无符号数以u或者U结尾
- unsigned long以ul或者UL结尾
- 没有后缀的浮点数位double类型
- flout类型后缀f或者F
- 后缀l或者L为long double
- 整形可以用八进制和十六进制表示，八进制是前缀为0的数，十六进制的前缀为0x或者0X。后面也可以跟UL后缀。
- 一个字符常量是一个整数

| 转义字符 | 描述       |
| -------- | ---------- |
| \a       | 响铃符     |
| \b       | 回退符     |
| \f       | 换页符     |
| \n       | 换行符     |
| \r       | 回车符     |
| \t       | 横向制表符 |
| \v       | 纵向制表符 |
| \\\      | 反斜杠     |
| \?       | 问号       |
| \\'      | 单引号     |
| \\"      | 双引号     |
| \ooo     | 八进制数   |
| \xhh     | 十六进制数 |
| \0       | 空字符     |

- 常量表达式时仅仅包含常量的表达式，编译时求值
- 字符串常量也叫字符串字面值
- "hello," " world" 等于"hello, world"
- 字符串的内部表示使用一个空字符'\0'表示字符串的结尾。
- 'x'和"x"是不同的，前者是一个字符常量，是一个整数，后者是一个包含一个字符x和结束符的字符数组。

### 枚举

- 枚举是另一种类型的常量，是一个常量整值型的列表。
- 隐式情况下，enum类型中第一个枚举名的值为0，第二个为1
- 如果只指定部分的枚举名的值，未指定的枚举名根据最后一个指定值，向后递增
- 不同枚举中的名字必须互不相同，同一枚举中的不同名字可以有相同的值。
- 相比#define，枚举常量值可以自动生成。声明enum类型的变量，编译器不检查变量中存储的值是否为该枚举的有效值，枚举变量提供这种检查。

## 声明

- 变量不是自动变量，只能进行一次初始化。
- 初始化表达式必须为常量表达式
- 默认情况下，外部变量和静态变量初始化为0

### const

- 指定变量的值不能被修改
- 指定数组所有元素不能修改。
- 配合数组参数使用，表明函数不能修改数组元素的值。

## 算数运算符

- \+ \- * / %
- %不能应用于float，double，
- 有负操作数，整数的除法街区的方向以及取模运算结果的符号取决于具体的机器实现。和处理上溢，下溢一样，

## 关系运算符和逻辑运算符

- 关系运算符的优先级比算数运算符低
- 相等性运算符优先级低于关系运算符（> >= < <=）
- &&优先级比||低 ，两者都比关系运算符和相等性运算符低。

## 类型转换

- 自动转换是指把"比较窄的"转换为"比较宽的"。
- c语言没有指定char类型的变量是无符号变量还是有符号变量
- c语言的定义保证了机器的标准打印字符集中的字符不会是负值。
- 如果要在char类型中存储非字符数组，最好指定符号限定符
- 真意味着非0
- float不会转换为double，使用float主要是为了使用较大的数组节省存储空间，有时也为了解释机器执行时间。
- 对于unsigned转换，首先需要整型提升，然后需要整型转换
- 赋值时需要类型转换，右值转换为左值
- 字符型变量转换为int类型
- 把较长的整数类型转换为较短的整数类型或char时，超出高位部分将会被丢弃。
- double转为float，四舍五入还是截取取决于具体实现
- 函数参数也可能进行类型转换，
- 强制类型转换

## 自增运算符和自减运算符

- ++n是先将n的值递增1，在使用n的值
- n++是先使用n的值，再将n值递增。

## 位运算符

- & 按位与
- | 按位或
- ^ 按位异或
- << 左移 右边空出的位用0填补
- \>\>右移 对unsigned，右边用0填补，对于signed，有些机器用符号位填补（算术移位），有些用0填补（逻辑移位）。
- ~按位取反

只能作用于整型操作数

## 赋值运算符

- =[\+ \- * / % \<\< \>\> & ^ |]
- 与x=x+1相比，只计算一次。
- 表示方式与人的思维比较相近
- x&=（x-1）可以删除最右边值为1的二进制位。

## 条件表达式

- expr1 ？ expr2 ：expr3
- 如果expr2，expr3的类型不同，结果的类型由转换规则决定。而不是由expr1的条件决定。

## 运算符优先级与求值顺序

| 运算符                                      | 结合性   |
| ------------------------------------------- | -------- |
| () [] -> .                                  | 从左至右 |
| ! ~ ++ -- + - * & (type) sizeof(一元运算符) | 从右至左 |
| * / %                                       | 从左至右 |
| + -                                         | 从左至右 |
| << >>                                       | 从左至右 |
| < <= > >=                                   | 从左至右 |
| == !=                                       | 从左至右 |
| &                                           | 从左至右 |
| ^                                           | 从左至右 |
| \|                                          | 从左至右 |
| &&                                          | 从左至右 |
| \|\|                                        | 从左至右 |
| ？：                                        | 从右至左 |
| = += -= *= /= %= &= ^= \|= <<= >>=          | 从右至左 |
| ,                                           | 从左至右 |

- c语言没有指定同一个运算符中多个操作数的计算顺序
- 没有指定函数各参数的求值顺序
- 函数调用，嵌套赋值语句，自增与自减可能会产生副作用。
- ANSI C标准明确规定了所有对参数的副作用都必须在函数调用前生效。

逗号运算符，一般在for循环中用到。分隔函数的参数，分隔声明中变量的逗号，并不是逗号运算符，这些逗号不保证从左至右的顺序求值，（慎用，适用于关系紧密的结构中）。

goto语句，都能改写为不适用goto的程序。会增加一些额外的重复测试或变量。尽量少用goto。

# 函数与程序结构

## 函数的基本知识

- 如果函数定义中省略了返回值，默认是int类型，

- unix系统中

  ```
  cc main.c getline.c strindex.c
  ```

  编译这三个文件，生成的目标代码分别放到文件main.o getline.o strindex.o中，再把这三个文件一起加载到a.out可执行文件中。

  ```
  cc main.c getline.o strindex.o
  ```

  如果mian.c中有错误，可只编译main文件。

- 返回非整型值函数，声明返回类型，调用时可以声明函数。

## 外部变量

- c程序可以看成由一系列外部对象构成，外部对象可能是变量或函数。
- 外部变量可以在全局范围内访问。
- 外部变量具有更大的作用域和生存期

## 作用域规则

- 如果要在外部变量的定义之前使用该变量，或者外部变量的定义与变量的使用不在一个文件中，则必须在相应的变量声明中强制性的使用extern
- 变量的声明，用于说明变量的属性
- 变量的定义，除此以外还会引起存储器的分配。
- 一个外部变量只能在某个文件中定义一次。
- 外部变量的初始化，只能出现在其定义中。

## 头文件

- 一个中等规模的程序，最好只用一个头文件存放程序中各部分共享对象。

## 静态变量

- 用static声明限定外部变量与函数。
- static声明函数，只能在所在文件可见
- static声明内部变量，只能在该函数使用，但是会一直占据存储空间的变量，

## 寄存器变量

- 只能修饰自动变量（局部变量）
- 过量的寄存器声明，没有害处。

## 程序块结构

- 静态变量只在第一次进入程序块的时候初始化一次

## 初始化

- 不显式初始化时，外部变量和静态变量初始化为0；寄存器变量和自动变量为未定义。
- 外部变量和静态变量来说，初始化表达式必须时常量表达式。
- 自动变量和寄存器变量，可以不是常量表达式。
- 初始化数组的个数要小于等于数组元素的个数。
- 字符串数组可以用字符串数组初始化。

## 递归

```c
void qsort (int v[], int left, int right) {
    int i, last;
    void swap(int v[],int i, int j);
    
    if (left >= right)
        return;
    swap(v, left, (left + right)/2);
    last = right;
    for (i = left + 1; i <= right; i++)
        if (v[i]<v[left])
            swap(v, ++lat, i)
    swap(v, left, last);
    qsort(v, left, last-1);
    qsrot(v, last+1, right);
}

void swap(int v[], int i, int j) {
    int temp;
    temp = v[i];
    v[i] = v[j];
    v[j] = temp;
}
```

## c预处理器

- 预处理器是编译过程中单独执行的第一个步骤。
- 文件包含include，如果某个包含的文件的内容发生了变化，那么所有依赖于该包含文件的源文件都必须重新编译。
- 宏替换。（是一种模板编程的原型）可以避免运行时的开销
- #前缀，扩展为由实际参数替换该参数的单引号的字符串。
- ##连接两个参数
- 条件包含，判断条件是常量整型表达式，其中不能包含sizeof，类型转换运算符，或者enum变量。

# 指针与数组

- 指针是一种保存变量地址的变量。

## 指针与地址

- &，只能用于内存中的对象，不饿能用于表达式，常量，register类型的变量。
- *，间接寻址或者间接引用计算符
- void类型指针可以存放指向任何类型的指针，不能间接引用自身。
- 一元运算符*和&优先级比算数运算符高。

## 指针与函数参数

- 函数参数是通过传值的方式。

## 指针与数组

- 用指针编写的程序比数组用下标编写的程序执行速度快。
- 指针加一，意味着指向指针所指向的对象的下一个对象。
- pa=&a[0]等同于pa=a；
- a[i]等价于*（a+i）
- &a[i]和a+i的含义也是相同的。
- 一个通过数组和下标实现的表达式可等价的通过指针和偏移量实现。
- 指针是一个变量，pa=a，pa++是合法的，数组名a=pa，a++是非法的。数组之间不能赋值
- 在函数定义中char s[]和char *s是等价的。
- 如果a是一个数组，f(&a[2])和f(a+2)是等价的。

## 地址算数运算

- 将指针数组和地址的算术运算集成在一起是该语言的一大优点。
- 对指针有意义的初始化值只能是0或者是表示地址的表达式。
- 指向同一个数组成员之间的指针可以进行比较
- 任何指针与0进行比较都有意义。
- 指针的算数运算中可使用数组最后一个元素的下一个元素的地址。
- 指向同一个数组元素的指针之间可以进行相加相减运算。
- 不经强制类型转换而直接将指向一种类型对象的指针赋值给指向另一种类型对象的指针的运算是非法的（其中一个指针是void *类型的除外）

## 字符指针与函数

- 字符串常量是一个数组。

- c语言没有提供将整个字符串作为一个整体进行处理的运算符。

- 如果试图修改一个指向字符串常量的指针指向字符串的值，结果是没有定义的。

- ```c
  //use array
  void strcpy(char *s, char *t) {
      int i;
      i= 0;
      while ((s[i] = t[i]) != '\0')
          i++;
  }
  //use *p
  void strcpy(char *s, char *t)
  {
      while (*s++ = *t++)
          ;
  }
  ```

## 指针数组以及指向指针的指针

```c
char *lineptr[MAXLINES] //指针数组，数组的每个元素是一个指向字符类型的指针。
```

## 多维数组

- 二维数组是一个特殊的一维数组，

- 数组元素按行存储

- ```c
  f(int daytab[2][13]) {...}
  f(int daytab[][13]) {...}
  f(int (daytab*)[13]) {...}//equally [] priority is greater than *
  ```

## 指针数组的初始化

```c
char * name[] = {
"illegal month",
"january",...
}
```

## 指针与多维数组

- 二维数组与指针数组

- ```c
  int a[10][20];//真正的二维数组，分配了200个int类型长度的存储空间
  int *b[10];//只是分配了10个指针，每行的长度可以不同
  ```

## 命令行参数

- ```c
  main(int argc, char *argv[]) {...}
  
  ```

- argc至少为1，argv[argc]在ANSI标准中必须为一个空指针

- UNIX系统中的C语言程序有一个公共的约定：以负号开头的参数表示一个可选标志或参数，

```c
//find.c
main (int argc, char *argc[]) {
    char line[MAXLINE];
    long lineno = 0;
    int c, except = 0, number = 0, found = 0;
    while (--argc > 0 && (*++argv)[0] == '-')
        while (c = *++argv[0])
            switch (c) {
                case 'x':
                    except = 1;
                    break;
                case 'n':
                    number = 1;
                    break;
            }
}//可匹配-x -n以及-xn

```

## 指向函数的指针

- 模板编程的思想，通过函数指针作为一个函数的参数来实现。
- void *可以理解为一个通用的基类。

## 复杂声明

- C语言的语法力图使声明和使用相一致



# 结构

- ```c
  struct point {
  	int x,
      int y,
  };//point 称为结构标记，可选的，
  struct {...} x, y, z; //声明定义一种结构类型
  struct point pt;//定义了一个变量
  struct point maxpt = {320,230};//通过赋值初始化
  pt.x; //访问成员
  
  ```

## 结构与函数

- 结构的合法操作：作为一个整体复制和赋值，通过&运算符取地址，访问其成员。

- 复制和赋值包括向函数传递参数以及从函数返回

- 结构之间不可以比较

- 可以用一个常量成员值列列表初始化结构

- 自动结构也可以通过复制进行初始化

- 在所有运算符的优先级最高的右，结构运算符`.`和`*`用于函数调用的`()`，用于下标的`[]`

- ```c
  *p->str
  *p->str++ //先读取指针str指向的值，再将str加一
  (*p->str)++ //读取指针str指向的值加一
  *p++->str //先读取str指向的对象的值，然后将p加一
  
  ```

## 结构数组

- ```c
  struct key {
      char *word;
      int count;
  }
  struct key keytab[NKEYS];
  
  ```

- C语言提供一个编译时一元运算符sizeof，可以用来 计算任意对象的长度；

- sizeof的返回值说无符号整型值，类型为size_t

- ```c
  sizeof 对象
  sizeof(类型名)
  #define NKEYS (sizeof keytab / sizeof(struct key))//只适用于struct key数组
  #define NKEYS (sizeof keytab / sizeof keytab[0]) //类型改变了也不用改动程序
  
  ```

- #if中不能使用sizeof，预处理器不对类型名进行分析。#define中可以使用sizeof，因为预处理器并不计算#define语句中的表达式。

## 指向结构的指针

- 两个指针之间的加法是非法的，但是两个指针之间的剑法是合法的。
- &tab[-1]和&tab[n]，前者是绝对非法的，对后者的间接引用时非法的,C语言的定义保证数组之后的第一个元素的指针算数运算可以正确执行。
- 结构的长度不等于各成员长度的和，存在未命名的空穴。

## 自引用结构

- 一个包含其自身的实例的结构时非法的，但是可以包含指向其自身类型的指针。

- ```c
  struct tnode {
      char *word;
      int count;
      struct tnode *left;
      struct tnode *right;
  };
  ```

- 内存分配问题

- 如果在大多数实际机器上满足各种类型对象的对齐要求

- 使用什么样的声明能处理分配程序必须能返回不同类型的指针问题；（void*）

## 表查找

- 散列表与链表结合；

## 类型定义（typedef）

- typedef中声明的类型在变量名的位置出现，而不是紧接在关键字typedef之后。语法上类似extern和static
- typedef类似于#define，但由于typedef是由编译器解释的，因此他的文本替换功能要超过预处理器的能力。
- 可以使表达更加简洁，
- 使程序参数化，提高程序的可移植性。
- 提供更好的说明性

## 联合

- 可以在不同时刻保存不同类型和长度的对象的变量

- 编译器负责跟踪对象的长度和对齐。

- 提供了一种方式，可以在单块存储区中管理不同类型的数据

- ```c
  union u_tag {
      int ival;
      float fval;
      char *sval;
  }u; //变量u必须足够大，保存3中类型中最大的一种
  
  ```

- ```c
  联合名.成员
  联合指针->成员
  
  ```

- 读取类型必须是最近一次存入的类型

- 程序员负责跟踪当前保存在联合中的类型

- 联合是一个结构，所有成员相对于及地址的偏移量都为0，此结构空间要大到足够容纳最宽的成员，并且其对齐方式要适合于联合中所有类型的成员

- 允许的操作：作为一个整体单元进行赋值，复制，取地址及访问其中一个成员。

- 联合只能用其第一个成员类型的值进行初始化，因此，上述联合u只能用整数值进行初始化。

## 位字段

- 需要将多个对象保存在一个机器字中。

- ```c
  #define KEYWORD 01
  #define EXTERNAL 02
  #define STATIC 04
  
  enum{
      KEYWORD = 01,
      EXTERNAL = 02,
      STATIC = 04
  };
  
  flag |= EXTERNAL | STATIC;
  flag &= ~(EXTERNAL | STATIC);
  if ((flag & (EXTERNAL | STATIC)) == 0) ...
  
  struct {
      unsigned int is_keyword : 1;
      unsigned int is_extern : 1;
      unsigned int is_static : 1;
  } flags;
  
  flags.is_extern = flags.is_static = 1;
  flags,is_extern = flags.is_static = 0;
  if (flags.is_extern == 0 && flags.is_static == 0)
      ...
  
  ```

- 那端优先和机器相关

- 字段不是数组，并且没有地址，不能使用&运算符。

- 需要显示声明该int类型是signed还是unsigned

# 输入与输出

## 标准输入/输出

- ```c
  int getchar(void);
  int putchar(void);
  int printf(char *format, arg1, arg2, ...)//return numbers of char
  
  ```

## 格式化输出——printf函数

- 负号：用于指定被转换的参数按照左对齐的形式输出
- 数：指定最小字段宽度，
- 小数点：用于将字段宽度和精度分开
- 数：用于指定精度
- 字母h或l：将整数作为short和long类型打印

| 字符 | 参数类型；输出形式                                           |
| ---- | ------------------------------------------------------------ |
| d，i | int类型；十进制数                                            |
| o    | int类型；无符号八进制数                                      |
| x，X | int类型；无符号十六进制数                                    |
| u    | int类型；无符号十进制数                                      |
| c    | int类型；单个字符                                            |
| s    | char *类型；                                                 |
| f    | double类型，默认精度6                                        |
| e，E | double类型；                                                 |
| g，G | double类型；指数小于-4或大于等于精度，用e和E输出，否则f输出，尾部的0和小数点不打印 |
| p    | viud *类型；指针                                             |
| %    | 不转换参数，打印一个百分号%                                  |

- 在转换说明中，宽度和精度可以用*表示，这是宽度和精度的值通过转换下一个参数来计算；

## 变长参数列表

- 省略号只能出现在参数表的尾部
- <stdarg.h>包含了一组宏定义，他们对如何遍历参数表进行了定义，该头文件的实现因不同的机器而不同，但提供的接口是一致的。

## 格式化输入——scanf函数

- 空格或制表符，在处理过程中将被忽略
- 普通字符（不包括%）用于匹配输入流中下一个非空白符字符
- 转换说明，依次由一个%，一个可选的赋值禁止字符*，一个可选的数值（指定最大字段宽度），一个可选的h，l或L字符（指定目标对象宽度）以及一个转换字符组成。
- 所有参数必须是指针。

## 文件访问

- fopen返回一个文件指针，它指向一个包含文件信息的结构。
- FILE是一个类型名，而不是结构标记。
- stdin和stdout都是FILE*类型的对象
- fclose函数

## 错误处理——stderr和exit

- stderr类似stdout和stdin是一种输出流
- exit标准库函数，将终止该程序

## 行输入和行输出

- fgets类似于getline
- gets函数在读取字符串时将删除结尾的换行符，而puts函数在写入字符串的时候将在结尾添加一个换行符
- gets和puts是对stdin和stdout进行操作的。
- ANSI规定，ferror在发生错误的时候返回非零值，fputs在发生错误是返回EOF，其他情况返回一个非负值。

## 其他函数

- 字符串操作函数
- 字符串类别测试和转换函数
- ungetc函数 将字符c会写到文件fp中
- 命令执行函数 system("date")
- 存储管理函数 malloc和calloc（存储控件初始化为0）free释放malloc和calloc申请的空间
- 数学函数

## 随机数发生器函数

- ```c
  #define frand() ((double) rand() / (RAND_MAX + 1.0))//生成浮点随机数
  
  ```

# UNIX系统接口

## 文件描述符

- 所有的外围设备都被看作是文件系统中的文件
- 意图通知系统，称为打开文件
- 任何时候对文件的输入输出都是通过文件描述符标志文件，而不是通过文件名标识文件
- 文件描述符类似于文件指针
- 当命令解释程序运行一个程序的时候，它将打开三个文件

## 低级I/O——read和write

```c
int n_read = read(int fd, char *buf, int n)
int n_write = write(int fd, char *buf, int n)

```

## open,create,close和unlink

- 出标准输入和标准输出，标准错误文件之外，其他文件必须在读或者写之前显示的打开，系统用open和create用于实现该功能

- ```c
  fd = open(name,O_RDONLY, 0)
  
  ```

- create创建文件

- close用来断开文件描述符和已知文件之间的连接，并释放此文件描述符，程序通过exit函数推出或从主程序中返回，所有打开的文件将会关闭。

- unlink将文件name从文件系统中删除，

## 随机访问——lseek

- ```c
  long lseek(int fd, long offset, int origin)//fd为文件描述符，origin由1，2，3三个值，分别指定offset从文件开始，当前位置，或从文件结束处开始算起
  
  ```

## 实例——fopen和getc函数的实现

- ```c
  typedef struct _iobuf {
      int cnt;//剩余的字符数
      char *ptr;//下一个字符位置
      char *base;//缓冲区的位置
      int flag;//文件访问模式
      int fd; //文件描述符
  } FILE;
  
  ```

## 实例——目录列表

- UNIX的目录就是一种文件，如果需要获取文件的其他信息，比如长度，需要系统调用。
- 目录就是文件，它包含了一个文件名列表和一些指示文件位置的信息。
- 位置是一个指向其他表（i节点）的索引。

## 实例——存储分配程序

- 通过一种与系统无关的方式编写与系统有关代码是应考虑的问题
- malloc不是在编译时就确定的固定大小的数组中分配存储空间
- malloc管理的空间不一定是连续的，
- malloc管理了一个空闲闭环链表。

